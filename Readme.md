# CS50x 2024
* Scratch week(Lecture 0):
  * Project Pending

* C language(Lecture 1):
  * %s ---> placeholder, Format code
  * Truncation decimal
  * typecasting
  * %.20f
  * int 4 bytes char 1 byte float real no 4 bytes double 8 
  * unsigned---> quialifier
  * logical operators and relational operators
  * Switch statement, int x = (exp) ? 5:6;
  * Linux Commands ---> cntrl L, cd--> home, cp, cp -r,rm -r,rm -rf

* Arrays (Lecture 2):
  * clang, ./a.out, clang -o name file
  * clang -o name file -lLibraryname
  * #--> Preprocessor Directive
  * cs50 lib contains a prototype for a get_string() func
  * Preprocessing --> Compiling --> Assembling --> linking
  * debug50
  * printf, debugger, Duck
  * Global variable const int N = 2
  * Array sentinal value 00000000-->NUL
  * \0 in string
  * Strings are 2d array of characters
  * strlen()
  * cmd line arguments 
  * argc, argv
  * argv[0]-->string,argv[1]-->null
  * cowsay -f,
  * exit status codes--> 0
  * return 1 and return 0 echo $?
  * root 13 algorithm
  * 

* Algorithms(Lecture 3):
  * Divide and Conquerer Algorithm
  * Linear and Binary search
  * O notation  upper bound, Omega notation lower bound--
  * Omega(2)-->Omega(1)
  * if bigO and omega are same: theta notation
  * strcmp()
  * typedef struct {} name;--> new datatype, .--> for attribute accessing
  * selection sort, --> n-1,n-2....n(n-1)/2, O(n2), omegasort(n2)
  * bubble sort--> n-2, Asmtotic notation, O(n2), omega(n)
  * recursion--> factorial
  * call-stack
  * merge sort O(nlog2n),

* Memory(Lecture 4):
  * %p, &a, *-->dereference operator
  * int *p = &a
  * pointer arthimatic
  * stdlib, malloc --> malloc(strlen(string-1), 1); return the pointer to the first char of that memory chunk and also check terminating confition
  * free and if malloc returns null it means it does not enough memory
  * strcpy(d,s)
  * free(t)
  * nul and null--> oth address--> sentinal value
  * valgrind
  * sizeof()
  * 3*sizeof(int) --> array
  * memory leaks
  * garbage values-- patterns of zeros and ones
  * intialy pointers point to pointees
  * Scopes---> Global and local
  * MC->GV->heap-><-stack
  * passing by value, passing by reference
  * heap overflow and Stack overflow
  * buffer overlows.
  * scanf("",&)
  * File IO--> fopen("","a"), fclose, fprinf, fscanf, fread, fwrite
  * fseek --> 
  * fopen --> 
  * stdint --> typedef uint8_t BYTE
  * 

* Data Structures(Lecture 5):
  * abstract Datatypes: queues-fifo(enqueue, dequeue), stacks-LIFO(puch,pop)
  * arrays: dynamic memory allocation
  * LinkedList--> pointers typedef struct node{struct node *next}node, 
  * prepending: O(1) for inserting, O(n) for searching
  * appending : O(n) for inserting
  * Tress --> BST sorted(LOGN)
  * Dictnories: keys and value
  * Hashing: D->R(mapping), hashtable(array-->linkedlist)
  * hashvalue and location-->O(n/k)-->buckets-->O(n)
  * unsigned int (const char *word){}
  * Tries--> tress of arrays
  * we don't use tries because of large space.
  * arrays: insertion and deletion.only for lookup
  * insertion and deletion is good bt lookup is bad
  * hashtable is good for lookup.
  * tries is not good space wise.
  * struct node mycar{}
  * delection in SLL is recursion
  * for collision in hashmap: we use linear probing--> not good(clustering)
  * in hashmaps we use chaining --> for that we bring linked list
  * tries--> data + multiple pointers and also has traversal pointer but also required alot of space
  * Stacks: lifo and by arrays and LL(insert and delete from the front), Push and Pop
  * queue: fifo and by arrays and LL(DLL), Enqueue and dequeue

*  



